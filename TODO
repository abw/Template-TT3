There's lots TODO.  This file contains a few notes to remind me about 
some of the things that need to be done.  It is in no way meant to be 
a comprehensive list.

-----------------------------------------------------------------------

Elements
--------
..  num_range       
to  num_to          # not just nums: 'A' to 'Z'
by  num_by          # ditto - needs iterator
?   if_then         #
:   if_else
->  arrow           # needs LHS signature recognition (almost there)
=   assign          # parallel assignment is TODO: @a = @b
<spec>              # template uri path query


Delete position() and other source methods from T::Type::Text

Move the temporary html() method in the 'Is' command to the T::TT3::HTML
module.  But it has to be installed into a base class for block commands
so that we don't need to poke it into is(), as(), for(), if(), etc., and
every other command that has block output.  That said, I'm not sure if it's
possible.  We may have to explicitly add html() methods to all the block
commands.  That feels like a little bit of a dirty specialisation, but we
have to embrace the fact that TT is (guessing) 99% used for generating 
HTML.  It would be better if we could do it generically (as original planned
for the HTML extensions - they would just adorn existing classes with 
html() methods).  But we can't expect the HTML extension to know about every
class.  Nor can we expect every block-based element to know about every 
possible output format (although asking them to know HTML wouldn't be so
bad).  Smells a bit dirty.

Figure out what non-chaining infix operators should do.

Figure out why element classes aren't being loaded.  e.g. declaring 
[ TAGS => ctr_tags => 0, 0 ] should load T::TT3::Element::Control::Tags
and fail if it doesn't exists.  The find() method appears to be returning
the class name without checking to see if it can be loaded.

Add name(), pair() and pairs() methods to all elements that require them.

Fix the regexes that are constructed for the outline tag so they don't 
consume newlines in comments, whitespace, etc.  Also make the end tag
optional and accept a simple string as a start token which gets compiled
to qr/^$start/.

Change element 'list_values()' to 'items()', or figure out how to map it
properly onto value/values.

Add T::TT3::Element::Signature which defines the signature construct. We need
this to reconstitute args for error reporting, e.g. in T::E::Command::Sub.

Figure out what to do with PARAMS.  They don't get recognised as HASH vars
so they don't get the same behaviours that it has.  e.g. "a(%b) = c(%b)".
Here the '%b' isn't expanded as a hash because it's a PARAMS not a HASH.

Avoid adding the default path to template_path so we can avoid creating
default file provider if we're only using text-based templates.

COMMANDS only installs commands into the grammar for the inline tag.  The
grammar should be shared between inline/outline.


Template::TT3::Templates/Hub/Config
-----------------------------------

Config needs to amalgamate arguments.  Decide if things like storage should
be enabled or not.  Hub needs to heed its call.

Also need to think *VERY* carefully about what different components may be
attaching to a prototype hub.  I'm concerned that creating a "leaf node"
template for temporary use in a subroutine might pull the whole framework
into persistence. 


Final Cleanup List
------------------

The following modules are believed to be complete, clean, tested and
documented.

   Template::TT3::Factory
   Template::TT3::Factory::Class
   Template::TT3::Engines
   Template::TT3::Dialects
   Template::TT3::Providers


