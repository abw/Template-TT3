You should read "syntax" first, then "directives".

All directives become expressions that can yield none or more values.
That include things we traditionally think of as "statement", like "if"
and "for" blocks.

Consider the following example:

    Hello [% name %]

This contains two expressions.  The first is a text chunk that always 
yields the static value 'Hello '.  The second is a variable expression
that yields whatever value the 'name' variable has at runtime.

A slightly more complex example:

    Hello [% name or 'World' %]

We still have two expressions, but the second is now a logical 'or' 
expression that yields either the value of the expression on its left
(the 'name' variable expression) or that of the expression on its right
(the "'World'" string).

TT3 understands operator precedence.

    [% a = b + c * d %]

This is parsed as:

    [% a = (b + (c * d)) %]

As you would expect, you can use parens if you want different precedence.

    [% a = (b + c) * d %]

Remember that everything in TT3 is an expression. For example, you can use the
'fill' command anywhere you can use a variable.

    [% a = fill header %]     # fill header template and save output in 'a'
    
    [% foo(fill header) %]    # fill header and pass output to foo()

Everything is an expression, even things like 'if' blocks.

    [% a = if b; 
         c;
       else;
         d;
       end
    %]

One thing that fall naturally out of this is generator expressions.  For 
example, if you want a list of the numbers from 1 to 10 you can write:

    1..10

Or if you prefer:

    1 to 10

But what if you want the numbers 10, 20, etc., up to 100?  That's easy:

    for x in 1 to 10;
        x * 10;
    end

The 'for' directive yields the values generated by its block.  So if you want
to capture the values and save them in a list, you can write this:

    numbers = [ 
      for x in 1 to 10;
        x * 10;
      end
    ]

Or if you prefer you can use braces to delimit blocks.

    numbers = [ 
        for x in 1 to 10 {
            x * 10;
        }
    ]

Because there's only a single expression in the 'for' block you can actually
do away with the braces.

    numbers = [ 
        for x in 1 to 10
            x * 10
    ]

With a single expression you can also write it in side-effect form:

    numbers = [ x * 10 for x in 1 to 10 ]

In this example the 'for' command is being interpreted as an infix operator
(as are '*', 'in' and 'to').  You can chain block expressions indefinitely 
in either direction:

    numbers = [ 
        for x in 1 to 10 {      # this example has stupid logic
            if x < 5 {          # but it illustrates the point
                x * 10
            }
        }
    ]

Or without the braces:

    numbers = [ 
        for x in 1 to 10
            if x < 5
                x * 10
    ]

Or in side effect form:

    numbers = [ 
        x * 10
            if x < 5
                for x in 1 to 10
    ]

All squished up:

    numbers = [ x * 10 if x < 5 for x in 1 to 10 ]

Remember you can use any commands as expressions.  Here are some examples
that all do the same thing: they generate a list containing the output
generated from processing three separate templates.

    # explicit
    output = [ 
       fill site/header
       fill site/content
       fill site/footer
    ]

    # generate from list
    output = [ 
       fill "site/$chunk" 
          for chunk in ['header', 'content', 'body']
    ]

    # generate from split string
    output = [ 
       fill "site/$chunk" 
          for chunk in 'header content body'.split
    ]
  
  