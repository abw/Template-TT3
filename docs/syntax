The core syntax of the TT3 language:

Constants

    10                    # integer
    3.142                 # float
    10e32                 # scientific
    0xDEADBEEF            # hex
  
Strings

    'single'              # single quote literal text
    'Mr O\'Brien'         # backslash escape '
    "double"              # double quoted text
    "it was 10\" long"    # backslash escape "
    "newline\nand so on"  # all the usual escape sequences
    "double $var"         # variables are interpolated
    "double ${foo}"       # explicit scoping
    "double ${foo.bar}"   # explicit scoping - see variable dotops
    "double \$var"        # backslash escape $ to prevent interpolation

Lists

    [10, 20]
    ['foo','bar']
    ['foo',10,'bar',20]

Hash arrays

    {a=10,b=20}     
    {a=>10,b=>20}         # '=>' is same as '=' in hash defs

Variables

    foo                   # implicit variable
    $foo                  # explicit $ variable sigil (usually same as above)
    var:foo               # explicit var: variable namespace

Variable dotops

    foo.bar
    foo                   # dotops can have whitespace before them
      .bar
      .baz

Literal dotops

    'foo'.length
    [10,20].size
    {pi=3.14,e=2.718}.

Interpolated dotops

    foo.$bar
    foo.${bar.baz}
    [10.20].$n

Variable arguments (functions and object methods)

    foo(10,20)
    foo(a=10)             # TT params
    foo(a=>10)            # regular Perl fat comma, same as foo('a',10)
    foo(10).bar(20)   
  
Variable assignment

    foo = 10              # set variable
    foo.bar = 20          # set dotted variable
    a = b = c = 10        # assignments can be chained, right associative

List expansion

    a = [10,20]
    b = [30,40]
    c = [@a,@b]           # same as: c = [10,20,30,40]
    @a                    # same as: 10, 20
    @a = @b               # update contents of a with contents of b
    @d = @b               # creates new list reference, same as: d = [@b]
    d = @b                # @b auto-folded to list reference, same as: d = [@b]

Hash expansion

    a = { x=10, y=20 }
    b = { p=19, q=23 }
    c = { %a, %b }      # same as: c = { x=10, y=20, p=10, q=23 }

    # I *think* it should be OK to allow @hash expansion
    d = [@a]            # same as: d = ['x', 10, 'y', 20]
    c = { @a, @b }      # same as: c = { %a, %b }

    # not sure about this... it kinda makes sense but could be weird
    %a                  # export contents of a, same as: x=10, y=20

Namespaces

    # terms can be prefixed with a namespace, either to clue the parser
    # up or to access external resources
    
    var:foo             # explicit variable, same as: $foo
    template:header     # reference a template
    file:example.txt    # reference a file
    ...plus others and your own custom namespaces...
    
Quote Ops (using namespaces)

    # q: is for single quoted strings
    q:/Single Quoted Text/    # These all do *exactly* the same thing.
    q:[Single Quoted Text]    # Note in particular that q:"foo $bar" is 
    q:{Single Quoted Text}    # a *single* quoted string because of the q:
    q:<Single Quoted Text>    # prefix.  It just happens to be using double
    q:'Single Quoted Text'    # quotes as delimiters.  The variable embedded
    q:"Single Quoted Text"    # in the string is *not* interpolated

    # qq: is for double quoted strings
    qq:/Blah $blah/           # same as "Blah $blah"
    qq:[Blah $blah]
    qq:[Blah "$blah"]         # same as "Blah \"$blah\""
    ...and all the same delimiters as above

    # qr: is for regexen.  It can have flags on the end
    qr:/^foo\s+/
    qr:/ ^ foo \s+ /sx
    qr:[^foo\s+]
    qr:[ ^ foo \s+ ]sx
    ...etc...

    # if a quotelike namespace is specified without delimiters then it 
    # consumes everything up to the next whitespace
    q:foo                           # same as 'foo', q:'foo', q:[foo] and so on
    q:foo.bar                       # same as 'foo.bar', etc.
    
    # this ties in with other namespaces that don't expect delimiters
    file:example.txt                # filenames don't need to be quoted
    template:header.html            # nor do template names
    http://foo.com/query?x=10&y=20  # nor do URIs / URLs
    
    # NOTE: quoting delimiters are namespace dependent.  For example,
    # file:, template:, http: and similar accept "" and '' but not []
    # // and so on.
    file:'my file.html'
    file:/slashes_are/part_of/the_path.html
    file:[blah]                     # same as file:'[blah]'     # BEWARE!        

    # The default namespace depends on context.  In most places a word
    # is treated as a variable:
    foo                             # these are both the same
    var:foo
    
    # In other places, a template name is expected
    fill example.html               # fill (nee INCLUDE) expects template:
    fill template:example.html      # same as above
    
    # you can over-ride the default
    fill var:foo.bar                # template name is in foo.bar var
    fill $foo.bar                   # short-hand sigil form, same as above

    # same goes for words following a dotop
    foo.bar                         # 'bar' is a bareword
    foo.$bar                        # 'bar' is a variable
    foo.var:bar                     # same as above (but clumsy)

    # blank namespace defaults to q:
    q:foo                           # same as: 'foo'
    :foo                            # same as above
